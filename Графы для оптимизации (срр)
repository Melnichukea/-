#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

// Структура для хранения ребер графа
struct Edge {
    int to;
    int weight;
};

// Функция для поиска кратчайшего пути
void dijkstra(const vector<vector<Edge>>& graph, int start) {
    int n = graph.size();
    vector<int> dist(n, INT_MAX); // Расстояния от начальной вершины
    vector<bool> visited(n, false);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    
    dist[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        for (const auto& edge : graph[u]) {
            int v = edge.to;
            int weight = edge.weight;
            
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    
    // Вывод результатов
    cout << "Кратчайшие расстояния от вершины " << start << ":\n";
    for (int i = 0; i < n; ++i) {
        cout << "До вершины " << i << ": " << dist[i] << "\n";
    }
}

int main() {
    // Создание графа
    int n = 5; // Количество вершин
    vector<vector<Edge>> graph(n);
    
    // Добавление ребер
    graph[0].push_back({1, 9});
    graph[0].push_back({2, 6});
    graph[0].push_back({3, 5});
    graph[2].push_back({1, 2});
    graph[2].push_back({3, 4});
    
    dijkstra(graph, 0);
    
    return 0;
}



//2 пример
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

// Структура для хранения ребер графа
struct Edge {
    int from;
    int to;
    int weight;
    
    // Оператор сравнения для приоритетной очереди
    bool operator<(const Edge& other) const {
        return weight > other.weight;
    }
};

// Функция для поиска минимального остовного дерева
void prim(const vector<vector<Edge>>& graph) {
    int n = graph.size();
    vector<bool> visited(n, false);
    priority_queue<Edge> pq;
    vector<Edge> mst;
    
    // Начинаем с вершины 0
    visited[0] = true;
    for (const auto& edge : graph[0]) {
        pq.push(edge);
    }
    
    while (!pq.empty() && mst.size() < n - 1) {
        Edge e = pq.top();
        pq.pop();
        
        if (visited[e.to]) continue;
        
        visited[e.to] = true;
        mst.push_back(e);
        
        for (const auto& edge : graph[e.to]) {
            if (!visited[edge.to]) {
                pq.push(edge);
            }
        }
    }
    
    // Вывод результата
    cout << "Минимальное остовное дерево:\n";
    for (const auto& edge : mst) {
        cout << "Ребро от " << edge.from << " до " << edge.to 
             << " весом " << edge.weight << "\n";
    }
}

int main() {
    // Создание графа
    int n = 5; // Количество вершин
    vector<vector<Edge>> graph(n);
    
    // Добавление ребер
    graph[




